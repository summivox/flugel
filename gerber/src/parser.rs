// Generated by rust-peg. Do not edit.
use self :: RuleResult :: { Matched , Failed } ; use super::types::*; fn escape_default ( s : & str ) -> String {
s . chars (  ) . flat_map ( | c | c . escape_default (  ) ) . collect (  ) }
fn char_range_at ( s : & str , pos : usize ) -> ( char , usize ) {
let c = & s [ pos .. ] . chars (  ) . next (  ) . unwrap (  ) ; let next_pos =
pos + c . len_utf8 (  ) ; ( * c , next_pos ) } # [ derive ( Clone ) ] enum
RuleResult < T > { Matched ( usize , T ) , Failed , } # [
derive ( PartialEq , Eq , Debug , Clone ) ] pub struct ParseError {
pub line : usize , pub column : usize , pub offset : usize , pub expected : ::
std :: collections :: HashSet < & 'static str > , } pub type ParseResult < T >
= Result < T , ParseError > ; impl :: std :: fmt :: Display for ParseError {
fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: result
:: Result < (  ) , :: std :: fmt :: Error > {
try ! (
write ! ( fmt , "error at {}:{}: expected " , self . line , self . column ) )
; if self . expected . len (  ) == 0 { try ! ( write ! ( fmt , "EOF" ) ) ; }
else if self . expected . len (  ) == 1 {
try ! (
write ! (
fmt , "`{}`" , escape_default (
self . expected . iter (  ) . next (  ) . unwrap (  ) ) ) ) ; } else {
let mut iter = self . expected . iter (  ) ; try ! (
write ! (
fmt , "one of `{}`" , escape_default ( iter . next (  ) . unwrap (  ) ) ) ) ;
for elem in iter {
try ! ( write ! ( fmt , ", `{}`" , escape_default ( elem ) ) ) ; } } Ok ( (  )
) } } impl :: std :: error :: Error for ParseError {
fn description ( & self ) -> & str { "parse error" } } fn slice_eq (
input : & str , state : & mut ParseState , pos : usize , m : & 'static str )
-> RuleResult < (  ) > {
# ! [ inline ] # ! [ allow ( dead_code ) ] let l = m . len (  ) ; if input .
len (  ) >= pos + l && & input . as_bytes (  ) [ pos .. pos + l ] == m .
as_bytes (  ) { Matched ( pos + l , (  ) ) } else {
state . mark_failure ( pos , m ) } } fn slice_eq_case_insensitive (
input : & str , state : & mut ParseState , pos : usize , m : & 'static str )
-> RuleResult < (  ) > {
# ! [ inline ] # ! [ allow ( dead_code ) ] let mut used = 0usize ; let mut
input_iter = input [ pos .. ] . chars (  ) . flat_map (
| x | x . to_uppercase (  ) ) ; for m_char_upper in m . chars (  ) . flat_map
( | x | x . to_uppercase (  ) ) {
used += m_char_upper . len_utf8 (  ) ; let input_char_result = input_iter .
next (  ) ; if input_char_result . is_none (  ) || input_char_result . unwrap
(  ) != m_char_upper { return state . mark_failure ( pos , m ) ; } } Matched (
pos + used , (  ) ) } fn any_char (
input : & str , state : & mut ParseState , pos : usize ) -> RuleResult < (  )
> {
# ! [ inline ] # ! [ allow ( dead_code ) ] if input . len (  ) > pos {
let ( _ , next ) = char_range_at ( input , pos ) ; Matched ( next , (  ) ) }
else { state . mark_failure ( pos , "<character>" ) } } fn pos_to_line (
input : & str , pos : usize ) -> ( usize , usize ) {
let before = & input [ .. pos ] ; let line = before . as_bytes (  ) . iter (
) . filter ( | && c | c == b'\n' ) . count (  ) + 1 ; let col = before . chars
(  ) . rev (  ) . take_while ( | & c | c != '\n' ) . count (  ) + 1 ; (
line , col ) } impl < 'input > ParseState < 'input > {
fn mark_failure ( & mut self , pos : usize , expected : & 'static str ) ->
RuleResult < (  ) > {
if self . suppress_fail == 0 {
if pos > self . max_err_pos {
self . max_err_pos = pos ; self . expected . clear (  ) ; } if pos == self .
max_err_pos { self . expected . insert ( expected ) ; } } Failed } } struct ParseState < 'input > { max_err_pos : usize , suppress_fail : usize , expected : :: std :: collections :: HashSet < & 'static str > , _phantom : :: std :: marker :: PhantomData < & 'input ( ) > , } impl < 'input > ParseState < 'input > { fn new ( ) -> ParseState < 'input > { ParseState { max_err_pos : 0 , suppress_fail : 0 , expected : :: std :: collections :: HashSet :: new ( ) , _phantom : :: std :: marker :: PhantomData , } } } 

 fn __parse_int_u8 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u8 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_int_u16 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u16 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_int_u32 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u32 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_int_u64 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u64 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_int_i8 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < i8 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = match { let __choice_res = slice_eq ( __input , __state , __pos , "+" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "-" ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_int_i16 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < i16 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = match { let __choice_res = slice_eq ( __input , __state , __pos , "+" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "-" ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_int_i32 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < i32 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = match { let __choice_res = slice_eq ( __input , __state , __pos , "+" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "-" ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_int_i64 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < i64 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = match { let __choice_res = slice_eq ( __input , __state , __pos , "+" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "-" ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_dec < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < d128 > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = { let str_start = __pos ; match { let __seq_res = match { let __choice_res = slice_eq ( __input , __state , __pos , "+" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "-" ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { match { let __seq_res = slice_eq ( __input , __state , __pos , "." ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = { let str_start = __pos ; match { let __seq_res = match { let __choice_res = slice_eq ( __input , __state , __pos , "+" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "-" ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "." ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  s.parse().unwrap()  } ) } Failed => Failed , } } } } } 

 fn __parse_hex_str < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' | 'a' ... 'f' | 'A' ... 'F' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9a-fA-F]" ) , } } else { __state . mark_failure ( __pos , "[0-9a-fA-F]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } } 

 fn __parse_hex_u8 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u8 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_hex_str ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  u8::from_str_radix(s, 16).unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_hex_u16 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u16 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_hex_str ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  u16::from_str_radix(s, 16).unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_hex_u32 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u32 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_hex_str ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  u32::from_str_radix(s, 16).unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_hex_u64 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < u64 > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_hex_str ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  u64::from_str_radix(s, 16).unwrap()  } ) } Failed => Failed , } } } 

 fn __parse_name < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] { let str_start = __pos ; match { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '_' | '.' | '$' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z_.$]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z_.$]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '_' | '.' | '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z_.0-9]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z_.0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } } 

 fn __parse_string < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '\r' | '\n' | '%' | '*' => __state . mark_failure ( __pos , "[^\r\n%*]" ) , _ => Matched ( __next , ( ) ) , } } else { __state . mark_failure ( __pos , "[^\r\n%*]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } } 

 fn __parse_field < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '\r' | '\n' | '%' | '*' | ',' => __state . mark_failure ( __pos , "[^\r\n%*,]" ) , _ => Matched ( __next , ( ) ) , } } else { __state . mark_failure ( __pos , "[^\r\n%*,]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } } 

 fn __parse_coord_raw < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < CoordRaw > { # ! [ allow ( non_snake_case , unused ) ] __parse_int_i64 ( __input , __state , __pos ) } 

 fn __parse_coord < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Coord > { # ! [ allow ( non_snake_case , unused ) ] __parse_dec ( __input , __state , __pos ) } 

 fn __parse_angle < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Angle > { # ! [ allow ( non_snake_case , unused ) ] __parse_dec ( __input , __state , __pos ) } 

 fn __parse_factor < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Factor > { # ! [ allow ( non_snake_case , unused ) ] __parse_dec ( __input , __state , __pos ) } 

 fn __parse_aperture_id < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < ApertureId > { # ! [ allow ( non_snake_case , unused ) ] __parse_int_u32 ( __input , __state , __pos ) } 

 fn __parse_macro_var_id < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroVarId > { # ! [ allow ( non_snake_case , unused ) ] __parse_int_u32 ( __input , __state , __pos ) } 

 fn __parse_macro_primitive_id < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroPrimitiveId > { # ! [ allow ( non_snake_case , unused ) ] __parse_int_u8 ( __input , __state , __pos ) } 

 fn __parse_command < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_command_op ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , c ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "*" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { c } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "%" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_command_ex ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , c ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "*%" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { c } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "%" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_command_am ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , c ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "%" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { c } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } 

 fn __parse_command_op < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_comment ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_g ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_d ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_d0 ( __input , __state , __pos ) } } } } } } } 

 fn __parse_comment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "G04" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_string ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  Comment(s)  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_g < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "G" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_int_u8 ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , a ) => { match { 
            match a {
                1 => Ok(Line),
                2 => Ok(ArcCW),
                3 => Ok(ArcCCW),
                74 => Ok(ArcSingleQuadrant),
                75 => Ok(ArcMultiQuadrant),
                36 => Ok(RegionStart),
                37 => Ok(RegionEnd),
                _ => Err("invalid G code"),
            }
         } { Ok ( res ) => Matched ( __pos , res ) , Err ( expected ) => { __state . mark_failure ( __pos , expected ) ; Failed } , } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_d < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "D" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_int_u32 ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , a ) => { Matched ( __pos , {  ApertureSelect(a)  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_d0 < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'X' | 'x' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[Xx]" ) , } } else { __state . mark_failure ( __pos , "[Xx]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_coord_raw ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , x ) => { { let __seq_res = match { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'Y' | 'y' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[Yy]" ) , } } else { __state . mark_failure ( __pos , "[Yy]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_coord_raw ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , y ) => { Matched ( __pos , { y } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , y ) => { { let __seq_res = match { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'I' | 'i' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[Ii]" ) , } } else { __state . mark_failure ( __pos , "[Ii]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_coord_raw ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , i ) => { Matched ( __pos , { i } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = match { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'J' | 'j' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[Jj]" ) , } } else { __state . mark_failure ( __pos , "[Jj]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_coord_raw ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , j ) => { Matched ( __pos , { j } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , j ) => { { let __seq_res = { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'D' | 'd' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[Dd]" ) , } } else { __state . mark_failure ( __pos , "[Dd]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_int_u32 ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , d ) => { Matched ( __pos , { d } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , d ) => { match { 
            (match d {
                1 => Ok(Interpolate),
                2 => Ok(Move),
                3 => Ok(Flash),
                _ => Err("invalid operation"),
            }).map(|d| Operation{x, y, i, j, d})
         } { Ok ( res ) => Matched ( __pos , res ) , Err ( expected ) => { __state . mark_failure ( __pos , expected ) ; Failed } , } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_command_ex < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_fs ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_mo ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_sr ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_ab ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_ad ( __input , __state , __pos ) } } } } } } } } } 

 fn __parse_fs < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "FSLA" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let __seq_res = slice_eq ( __input , __state , __pos , "X" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "Y" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __seq_res { Matched ( __pos , _ ) => { if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , { 
            let s = s.as_bytes();
            Format{
                xi: s[1] - '0' as u8,
                xf: s[2] - '0' as u8,
                yi: s[4] - '0' as u8,
                yf: s[5] - '0' as u8,
            }
         } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_mo < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "MO" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_mo_arg ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_mo_arg < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "IN" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  UnitInch  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "MM" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  UnitMm  } ) } Failed => Failed , } } } } } 

 fn __parse_l < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "L" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_l_arg ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_l_arg < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "PD" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  PolarityDark  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "PC" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  PolarityClear  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "MN" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  MirrorN  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "MX" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  MirrorX  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "MY" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  MirrorY  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "MXY" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  MirrorXY  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "R" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_angle ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , a ) => { Matched ( __pos , {  Rotate(a)  } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "S" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_factor ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , f ) => { Matched ( __pos , {  Scale(f)  } ) } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } } } } } } } } 

 fn __parse_sr < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "SR" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "X" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_int_u32 ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "Y" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_int_u32 ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , y ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "I" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_coord ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "J" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_coord ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , j ) => { Matched ( __pos , {  StepRepeat{x, y, i, j}  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "SR" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  StepRepeatClear  } ) } Failed => Failed , } } } } } 

 fn __parse_ab < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "AB" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_ab_arg ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_ab_arg < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "D" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_int_u32 ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , id ) => { Matched ( __pos , {  ApertureBlock(id)  } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , {  ApertureBlockClear  } ) } } } 

 fn __parse_ad < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "ADD" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_int_u32 ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , id ) => { { let __seq_res = __parse_name ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , macro_name ) => { { let __seq_res = match { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'X' | 'x' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[Xx]" ) , } } else { __state . mark_failure ( __pos , "[Xx]" ) } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = __parse_coord ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , args ) => { Matched ( __pos , { args } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , args ) => { Matched ( __pos , { 
            ApertureDefine{
                id,
                macro_name,
                args: args.unwrap_or(vec![]),
            }
         } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_command_am < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "AM" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_name ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "*" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = __parse_am_stmt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "*" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { s } ) } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , body ) => { Matched ( __pos , {  ApertureMacro{name, body}  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_am_stmt < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroStmt<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_am_comment ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_am_assign ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_am_primitive ( __input , __state , __pos ) } } } } } 

 fn __parse_am_comment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroStmt<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "0" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_string ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , {  MacroComment(s)  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_am_assign < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroStmt<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_am_var ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , l ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "=" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_am_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , r ) => { Matched ( __pos , {  Assign(l, r)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_am_primitive < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroStmt<'input> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_macro_primitive_id ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , p ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_am_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , args ) => { Matched ( __pos , {  Primitive(p, args)  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_am_expr < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroExpr > { # ! [ allow ( non_snake_case , unused ) ] { fn __infix_parse < 'input > ( __min_prec : i32 , __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroExpr > { if let Matched ( __pos , mut __infix_result ) = __parse_am_atom ( __input , __state , __pos ) { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; if 0i32 >= __min_prec { if let Matched ( __pos , _ ) = slice_eq ( __input , __state , __pos , "+" ) { if let Matched ( __pos , y ) = __infix_parse ( 1i32 , __input , __state , __pos ) { let x = __infix_result ; __infix_result = { MacroExpr::Bin(BinOp::Add, Box::new(x), Box::new(y))  } ; __repeat_pos = __pos ; continue ; } } if let Matched ( __pos , _ ) = slice_eq ( __input , __state , __pos , "-" ) { if let Matched ( __pos , y ) = __infix_parse ( 1i32 , __input , __state , __pos ) { let x = __infix_result ; __infix_result = { MacroExpr::Bin(BinOp::Sub, Box::new(x), Box::new(y))  } ; __repeat_pos = __pos ; continue ; } } } if 1i32 >= __min_prec { if let Matched ( __pos , _ ) = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'X' | 'x' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[Xx]" ) , } } else { __state . mark_failure ( __pos , "[Xx]" ) } { if let Matched ( __pos , y ) = __infix_parse ( 2i32 , __input , __state , __pos ) { let x = __infix_result ; __infix_result = { MacroExpr::Bin(BinOp::Mul, Box::new(x), Box::new(y))  } ; __repeat_pos = __pos ; continue ; } } if let Matched ( __pos , _ ) = slice_eq ( __input , __state , __pos , "/" ) { if let Matched ( __pos , y ) = __infix_parse ( 2i32 , __input , __state , __pos ) { let x = __infix_result ; __infix_result = { MacroExpr::Bin(BinOp::Div, Box::new(x), Box::new(y))  } ; __repeat_pos = __pos ; continue ; } } } break ; } Matched ( __repeat_pos , __infix_result ) } else { Failed } } __infix_parse ( 0 , __input , __state , __pos ) } } 

 fn __parse_am_atom < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroExpr > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_coord ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , {  MacroExpr::Lit(x)  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_am_var ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , {  MacroExpr::Var(x)  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "-" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_am_atom ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , {  MacroExpr::Neg(Box::new(x))  } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "+" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_am_atom ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_am_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ")" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } } 

 fn __parse_am_var < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < MacroVarId > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "$" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_macro_var_id ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , x ) => { Matched ( __pos , { x } ) } Failed => Failed , } } } Failed => Failed , } } } 

 pub fn int_u8 < 'input > ( __input : & 'input str ) -> ParseResult < u8 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_u8 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn int_u16 < 'input > ( __input : & 'input str ) -> ParseResult < u16 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_u16 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn int_u32 < 'input > ( __input : & 'input str ) -> ParseResult < u32 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_u32 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn int_u64 < 'input > ( __input : & 'input str ) -> ParseResult < u64 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_u64 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn int_i8 < 'input > ( __input : & 'input str ) -> ParseResult < i8 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_i8 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn int_i16 < 'input > ( __input : & 'input str ) -> ParseResult < i16 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_i16 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn int_i32 < 'input > ( __input : & 'input str ) -> ParseResult < i32 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_i32 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn int_i64 < 'input > ( __input : & 'input str ) -> ParseResult < i64 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_int_i64 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn dec < 'input > ( __input : & 'input str ) -> ParseResult < d128 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_dec ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn hex_str < 'input > ( __input : & 'input str ) -> ParseResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_hex_str ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn hex_u8 < 'input > ( __input : & 'input str ) -> ParseResult < u8 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_hex_u8 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn hex_u16 < 'input > ( __input : & 'input str ) -> ParseResult < u16 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_hex_u16 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn hex_u32 < 'input > ( __input : & 'input str ) -> ParseResult < u32 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_hex_u32 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn hex_u64 < 'input > ( __input : & 'input str ) -> ParseResult < u64 > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_hex_u64 ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn name < 'input > ( __input : & 'input str ) -> ParseResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_name ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn string < 'input > ( __input : & 'input str ) -> ParseResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_string ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn field < 'input > ( __input : & 'input str ) -> ParseResult < &'input str > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_field ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn coord_raw < 'input > ( __input : & 'input str ) -> ParseResult < CoordRaw > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_coord_raw ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn coord < 'input > ( __input : & 'input str ) -> ParseResult < Coord > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_coord ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn angle < 'input > ( __input : & 'input str ) -> ParseResult < Angle > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_angle ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn factor < 'input > ( __input : & 'input str ) -> ParseResult < Factor > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_factor ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn aperture_id < 'input > ( __input : & 'input str ) -> ParseResult < ApertureId > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_aperture_id ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn macro_var_id < 'input > ( __input : & 'input str ) -> ParseResult < MacroVarId > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_macro_var_id ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn macro_primitive_id < 'input > ( __input : & 'input str ) -> ParseResult < MacroPrimitiveId > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_macro_primitive_id ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn command < 'input > ( __input : & 'input str ) -> ParseResult < Command<'input> > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_command ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) } 

 pub fn am_expr < 'input > ( __input : & 'input str ) -> ParseResult < MacroExpr > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_am_expr ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) }